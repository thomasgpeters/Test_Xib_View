globals "DataObject.glbl"include "NSLog.incl"/* * Select Query Builder * Supporting Functions * * */local modedim as CFMutableArrayRef     selectfilterArrayReflocal fn GetSelectFilterArray( queryDictionaryRef as CFMutableDictionaryRef ) as CFMutableArrayRefif ( fn CFDictionaryContainsKey( queryDictionaryRef, @"filter" ) )selectfilterArrayRef = (CFMutableArrayRef)fn CFDictionaryGetValue( queryDictionaryRef, @"filter" )end ifend fn = selectfilterArrayReflocal modedim as CFMutableArrayRef     metadataArrayReflocal fn InitMetadataArray( queryDictionaryRef as CFMutableDictionaryRef )metadataArrayRef = fn CFArrayCreateMutable( _kCFAllocatorDefault, 0, @kCFTypeArrayCallBacks )fn CFDictionaryAddValue( queryDictionaryRef, @"metadata", metadataArrayRef )fn CFRelease( metadataArrayRef )end fnlocal modedim as CFMutableArrayRef     selecttablesArrayReflocal fn InitTablesArray( queryDictionaryRef as CFMutableDictionaryRef )selecttablesArrayRef = fn CFArrayCreateMutable( _kCFAllocatorDefault, 0, @kCFTypeArrayCallBacks )fn CFDictionaryAddValue( queryDictionaryRef, @"selecttables", selecttablesArrayRef )fn CFRelease( selecttablesArrayRef )end fnlocal modedim as CFMutableArrayRef     selectcolsArrayReflocal fn InitColumnsArray( queryDictionaryRef as CFMutableDictionaryRef )selectcolsArrayRef = fn CFArrayCreateMutable( _kCFAllocatorDefault, 0, @kCFTypeArrayCallBacks )fn CFDictionaryAddValue( queryDictionaryRef, @"selectcols", selectcolsArrayRef )fn CFRelease( selectcolsArrayRef )end fnlocal modedim as CFMutableDictionaryRef     associationsDictionaryReflocal fn InitAssociationsDictionary( queryDictionaryRef as CFMutableDictionaryRef )associationsDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, 0, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn CFDictionaryAddValue( queryDictionaryRef, @"associations", associationsDictionaryRef )fn CFRelease( associationsDictionaryRef )end fnlocal modedim as CFMutableArrayRef     selectfilterArrayReflocal fn InitFilterArray( queryDictionaryRef as CFMutableDictionaryRef )selectfilterArrayRef = fn CFArrayCreateMutable( _kCFAllocatorDefault, 0, @kCFTypeArrayCallBacks )fn CFDictionaryAddValue( queryDictionaryRef, @"filter", selectfilterArrayRef )fn CFRelease( selectfilterArrayRef )end fnlocal modedim as CFMutableDictionaryRef     resultsDictionaryReflocal fn InitResultsDictionary( queryDictionaryRef as CFMutableDictionaryRef )resultsDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, 0, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn CFDictionaryAddValue( queryDictionaryRef, @"results", resultsDictionaryRef )fn CFRelease( resultsDictionaryRef )end fnlocal modedim as CFMutableDictionaryRef   queryDictionaryReflocal fn InitQueryDictionary as CFMutableDictionaryRef/*  Setup the Dictionary with an empty results array */queryDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, NULL, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn InitMetadataArray( queryDictionaryRef )fn InitColumnsArray( queryDictionaryRef )fn InitTablesArray( queryDictionaryRef )fn InitAssociationsDictionary( queryDictionaryRef )fn InitFilterArray( queryDictionaryRef )fn InitResultsDictionary( queryDictionaryRef )end fn = queryDictionaryReflocal modedim as CFMutableArrayRef        selecttablesArrayRefdim as CFMutableDictionaryRef   tableDictionaryReflocal fn AddTableToQuery( queryDictionaryRef as CFMutableDictionaryRef, tableName as CFStringRef, aliasName as CFStringRef )'~'1if ( fn CFDictionaryContainsKey( queryDictionaryRef, @"selecttables" ) )selecttablesArrayRef = (CFMutableArrayRef)fn CFDictionaryGetValue( queryDictionaryRef, @"selecttables" )tableDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, NULL, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn CFDictionaryAddValue( tableDictionaryRef, @"tablename", tableName )fn CFDictionaryAddValue( tableDictionaryRef, @"aliasname", aliasName )fn CFArrayAppendValue( selecttablesArrayRef, tableDictionaryRef )fn CFRelease( tableDictionaryRef )end ifend fnlocal modedim as CFMutableArrayRef        selectcolsArrayRefdim as CFMutableDictionaryRef   columnDictionaryReflocal fn AddColumnToQuery( queryDictionaryRef as CFMutableDictionaryRef, columnName as CFStringRef, aliasName as CFStringRef)'~'1if ( fn CFDictionaryContainsKey( queryDictionaryRef, @"selectcols" ) )selectcolsArrayRef = (CFMutableArrayRef)fn CFDictionaryGetValue( queryDictionaryRef, @"selectcols" )columnDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, NULL, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn CFDictionaryAddValue( columnDictionaryRef, @"columnname", columnName )fn CFDictionaryAddValue( columnDictionaryRef, @"aliasname", aliasName )fn CFArrayAppendValue( selectcolsArrayRef, columnDictionaryRef )fn CFRelease( columnDictionaryRef )end ifend fn/*Operator           Meaninga = b              a is equal to ba != b             a is not equal to ba < b              a is less than ba > b              a is greater than ba <= b             a is less than or equal to ba >= b             a is greater than or equal to ba IN (b, c)        a is equal to either b or ca NOT IN (b, c)    a is equal to neither b nor c*/local modedim as CFMutableArrayRef        selectfilterArrayRefdim as CFMutableDictionaryRef   filterDictionaryReflocal fn AddFilterToQuery( queryDictionaryRef as CFMutableDictionaryRef, tableAlias as CFStringRef, columnName as CFStringRef, value as CFStringRef, type as long, numType as long, operator as long, logic as long )if ( fn CFDictionaryContainsKey( queryDictionaryRef, @"filter" ) )selectfilterArrayRef = (CFMutableArrayRef)fn CFDictionaryGetValue( queryDictionaryRef, @"filter" )filterDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, NULL, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn CFDictionaryAddValue( filterDictionaryRef, @"tablealias", tableAlias )fn CFDictionaryAddValue( filterDictionaryRef, @"columnname", columnName )if value != NULL then fn CFDictionaryAddValue( filterDictionaryRef, @"value", value )fn CFDictionaryAddValue( filterDictionaryRef, @"type", fn CFNumberCreate(_kCFAllocatorDefault, _kCFNumberLongType, @type) )if numType > 0 then fn CFDictionaryAddValue( filterDictionaryRef, @"numType", fn CFNumberCreate(_kCFAllocatorDefault, _kCFNumberLongType, @numType) )fn CFDictionaryAddValue( filterDictionaryRef, @"operator", fn CFNumberCreate(_kCFAllocatorDefault, _kCFNumberLongType, @operator) )if logic > 0 then fn CFDictionaryAddValue( filterDictionaryRef, @"logic", fn CFNumberCreate(_kCFAllocatorDefault, _kCFNumberLongType, @logic) )fn CFArrayAppendValue( selectfilterArrayRef, filterDictionaryRef )fn CFRelease( filterDictionaryRef )end ifend fn/*Operator           Meaninga = b              a is equal to ba != b             a is not equal to ba < b              a is less than ba > b              a is greater than ba <= b             a is less than or equal to ba >= b             a is greater than or equal to ba IN (b, c)        a is equal to either b or ca NOT IN (b, c)    a is equal to neither b nor c*/local modedim as CFMutableArrayRef        selectassociationsArrayRefdim as CFMutableDictionaryRef   associationDictionaryReflocal fn AddAssociationToQuery( queryDictionaryRef as CFMutableDictionaryRef, leftTableAlias as CFStringRef, leftColumnName as CFStringRef, rightTableAlias as CFStringRef, rightColumnName as CFStringRef, operator as long )'~'1if ( fn CFDictionaryContainsKey( queryDictionaryRef, @"associations" ) )selectassociationsArrayRef = (CFMutableArrayRef)fn CFDictionaryGetValue( queryDictionaryRef, @"associations" )associationDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, NULL, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn CFDictionaryAddValue( associationDictionaryRef, @"lefttablealias", leftTableAlias )fn CFDictionaryAddValue( associationDictionaryRef, @"leftcolumnname", leftColumnName )fn CFDictionaryAddValue( associationDictionaryRef, @"righttablealias", rightTableAlias )fn CFDictionaryAddValue( associationDictionaryRef, @"rightcolumnname", rightColumnName )fn CFDictionaryAddValue( associationDictionaryRef, @"operator", fn CFNumberCreate(_kCFAllocatorDefault, _kCFNumberLongType, @operator) )fn CFArrayAppendValue( selectassociationsArrayRef, associationDictionaryRef )fn CFRelease( associationDictionaryRef )end ifend fn/* * Types *dim as CFTypeID  typeIDtypeID = fn CFGetTypeID( thingOfUnknownType )select typeID  case fn CFStringGetTypeID()    fn DoSomethingWithString( thingOfUnknownType )  case fn CFDateGetTypeID()    fn DoSomethingWithDate( thingOfUnknownType )  case fn CFNumberGetTypeID()    fn DoSomethingWithNumber( thingOfUnknownType )  case else    stop "Oops"end select*//* * Insert Into Builder * Supporting Functions * * */local modedim as CFMutableStringRef     insertIntoTableStringReflocal fn InitInsertIntoTableString( insertDictionaryRef as CFMutableDictionaryRef )insertIntoTableStringRef = fn CFStringCreateMutable( _kCFAllocatorDefault, 0 )fn CFDictionaryAddValue( insertDictionaryRef, @"insertintotable", insertIntoTableStringRef )fn CFRelease( insertIntoTableStringRef )end fnlocal modedim as CFMutableDictionaryRef     insertColumnDictionaryReflocal fn InitInsertColumnsDictionary( insertDictionaryRef as CFMutableDictionaryRef )insertColumnDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, 0, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn CFDictionaryAddValue( insertDictionaryRef, @"insertcols", insertColumnDictionaryRef )fn CFRelease( insertColumnDictionaryRef )end fnlocal modedim as CFMutableDictionaryRef     columnTypesDictionaryReflocal fn InitColumnTypesDictionary( insertDictionaryRef as CFMutableDictionaryRef )columnTypesDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, 0, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn CFDictionaryAddValue( insertDictionaryRef, @"columntypes", columnTypesDictionaryRef )fn CFRelease( columnTypesDictionaryRef )end fnlocal modedim as CFMutableDictionaryRef   insertIntoDictionaryRef/* * insertDictionaryRef   <-- Holds the elements that make up an insert SQL statement *        | *        |___ insertIntoTableCFStringRef        <-- String holding of Table Name *        | *        |___ insertColumnDictionaryRef         <-- Dictionary holding of Column Data *        | *        |___ columnTypesDictionaryRef          <-- Dictionary holding of Column Types * */local fn InitInsertIntoDictionary as CFMutableDictionaryRef/*  Setup the Dictionary with an empty table, columns and column types references */insertIntoDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, NULL, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn InitInsertIntoTableString( insertIntoDictionaryRef )fn InitInsertColumnsDictionary( insertIntoDictionaryRef )fn InitColumnTypesDictionary( insertIntoDictionaryRef )end fn = insertIntoDictionaryReflocal modedim as CFMutableStringRef        insertTableStringReflocal fn AddTableToInsert( insertDictionaryRef as CFMutableDictionaryRef, tableName as CFStringRef )'~'1if ( fn CFDictionaryContainsKey( insertDictionaryRef, @"insertintotable" ) )insertTableStringRef = (CFMutableStringRef)fn CFDictionaryGetValue( insertDictionaryRef, @"insertintotable" )if ( insertTableStringRef )fn CFStringAppend( insertTableStringRef, tableName )// fn CFDictionarySetValue( insertDictionaryRef, @"insertintotable", insertTableStringRef )// fn CFRelease( insertTableStringRef )end ifend ifend fnlocal modedim as CFMutableDictionaryRef   insertColumnDictionaryRefdim as CFMutableDictionaryRef   columnTypesDictionaryRef/* * * Storage Class & Description * 1 NULL    The value is a NULL value. * 2 INTEGER The value is a signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes depending on the magnitude of the value. * 3 REAL    The value is a floating point value, stored as an 8-byte IEEE floating point number. * 4 TEXT    The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE) * 5 BLOB    The value is a blob of data, stored exactly as it was input. * */local fn AddColumnToInsert( insertDictionaryRef as CFMutableDictionaryRef, columnName as CFStringRef, columnValue as CFStringRef, columnType as CFStringRef )'~'1if ( fn CFDictionaryContainsKey( insertDictionaryRef, @"insertcols" ) )insertColumnDictionaryRef = (CFMutableDictionaryRef)fn CFDictionaryGetValue( insertDictionaryRef, @"insertcols" )if ( insertColumnDictionaryRef )fn CFDictionaryAddValue( insertColumnDictionaryRef, columnName, columnValue )// fn CFDictionaryAddValue( insertDictionaryRef, @"insertcols", insertColumnDictionaryRef )// fn CFRelease( insertColumnDictionaryRef )end ifend ifif ( fn CFDictionaryContainsKey( insertDictionaryRef, @"columntypes" ) )columnTypesDictionaryRef = (CFMutableDictionaryRef)fn CFDictionaryGetValue( insertDictionaryRef, @"columntypes" )if ( columnTypesDictionaryRef )fn CFDictionaryAddValue( columnTypesDictionaryRef, columnName, columnType )// fn CFDictionarySetValue( insertDictionaryRef, @"columntypes", columnTypesDictionaryRef )// fn CFRelease( columnTypesDictionaryRef )end ifend ifend fn/* * Delete From Builder * Supporting Functions * * */local modedim as CFMutableStringRef     deleteFromTableStringReflocal fn InitDeleteFromTableString( deleteDictionaryRef as CFMutableDictionaryRef )deleteFromTableStringRef = fn MutableStringWithCapacity( 0 )fn CFDictionaryAddValue( deleteDictionaryRef, @"deletefromtable", deleteFromTableStringRef )fn CFRelease( deleteFromTableStringRef )end fnlocal modedim as CFMutableArrayRef     insertcolsArrayReflocal fn InitDeleteColumnsArray( insertDictionaryRef as CFMutableDictionaryRef )insertcolsArrayRef = fn CFArrayCreateMutable( _kCFAllocatorDefault, 0, @kCFTypeArrayCallBacks )fn CFDictionaryAddValue( insertDictionaryRef, @"insertcols", insertcolsArrayRef )fn CFRelease( insertcolsArrayRef )end fnlocal modedim as CFMutableDictionaryRef   deleteFromDictionaryReflocal fn InitDeleteFromDictionary as CFMutableDictionaryRef/*  Setup the Dictionary with an empty results array */deleteFromDictionaryRef = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, NULL, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )fn InitDeleteFromTableString( deleteFromDictionaryRef )fn InitDeleteColumnsArray( deleteFromDictionaryRef )fn InitColumnTypesDictionary( deleteFromDictionaryRef )end fn = deleteFromDictionaryReflocal modeCFURLRef              url = fn URLWithString( @"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt" )CFStringRef        string = fn StringWithContentsOfURL( url, NSUTF8StringEncoding, NULL )CFArrayRef        tempArr = fn StringComponentsSeparatedByCharactersInSet( string, fn CharacterSetNewlineSet )CFMutableArrayRef dictArr = fn MutableArrayWithCapacity(0)CFStringRef       tempStrvoid local fn LoadAndCleanUnixDictionaryfor tempStr in tempArrCFRange range = fn StringRangeOfStringWithOptions( tempStr, @"^([a-z]{3,6})+$", NSRegularExpressionSearch )if range.location != NSNotFound then MutableArrayAddObject( dictArr, tempStr )nextAppSetProperty( @"unixdict", fn ArrayWithArray( dictArr ) )end fn