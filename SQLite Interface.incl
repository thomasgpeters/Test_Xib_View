// Create global URL to contacts.db on Desktop for duration of demo programlocal fn CreateGlobalURL as CFURLRef'~'1CFURLRef desktopURLCFURLRef aDatabaseURLdesktopURL = fn FileManagerURLForDirectory( NSDesktopDirectory, NSUserDomainMask )aDatabaseURL = fn URLByAppendingPathComponent( desktopURL, @"contacts.sqlite" )end fn = aDatabaseURL' Open SQLite3 Database connectionlocal fn OpenSQLite3Database( databaseURL as CFURLRef ) as BOOLBOOL isOpen' if ( fn FileManagerFileExistsAtURL( gDatabaseURL ) == _false )' ControlSetStringValue( _status1Label, @"Database missing. Relaunch app to create new database." )' exit fn' elseif ( fn SQL3Open( fn URLPath( databaseURL ), @gDatabasePtr ) == _SQLITEOK )isOpen = YESelseisOpen = NOend if' end ifend fn = isOpen' Close SQLite3 Database connectionlocal fn CloseSQLite3Database as BOOLBOOL isOpenif ( gDBIsConnected )fn SQL3Close( gDatabasePtr )isOpen = NOelseisOpen = YESend ifend fn = isOpenlocal fn OpenSQLite as long'~'1dim as long returnValuedim as CFURLRef myHomeDirURLfn NSLog( @"SQLite version = %ld", fn sqlite3_libversion_number() )myHomeDirURL = fn URLWithString(  @"/Users/thomaspeters/sqlite/" )// desktopURL = fn FileManagerURLForDirectory( NSDesktopDirectory, NSUserDomainMask )gDatabaseURL = fn URLByAppendingPathComponent( myHomeDirURL, @"MySQLite3.DB" )if ( fn FileManagerFileExistsAtURL( gDatabaseURL ) == YES )returnValue = fn SQL3Open( fn URLPath( gDatabaseURL ), @gDatabasePtr )if ( returnValue == _SQLITEOK )fn NSLog( @"SQLite Database opened at: %@", gDatabaseURL )end ifelsefn NSLog( @"SQLite Database not found" )end ifend fn = returnValuelocal fn CloseSQLite as longdim code as longif ( gDatabasePtr ) then code = fn SQL3Close( gDatabasePtr )end fn = codelocal modedim as long                      curColumn, columnType, rowCountdim as CFStringRef               columnNamedim as CFMutableArrayRef         resultsDataArrayRefdim as CFMutableDictionaryRef    queryResults, resultsColumnData, resultsMetadata/* * queryResults   <-- the return type *      | *      |___ resultsColumnNamesArrayRef        <-- an array of Column Names *      | *      |___ resultsMetadata                   <-- a Dictionary of Col Data Types     e.g. the Type of Data for each Column in a Row in the results *      | *      |___ resultsDataArrayRef               <-- an array of Row Data               e.g. each element in the array every row in the result set *                   | *                   | *                   |___ resultsColumnData    <-- a Dictionary of Col Data Types     e.g. the Data for each Column in a Row in the results */local fn ExecutePreparedStatement( statement as sqlite3_stmtPtr, queryDictionaryRef as CFMutableDictionaryRef ) as CFMutableDictionaryRefqueryResults = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, 0, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )resultsMetadata = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, 0, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )resultsDataArrayRef = fn CFArrayCreateMutable( _kCFAllocatorDefault, 0, @kCFTypeArrayCallBacks )rowCount = 0 'initialize rowCountwhile ( fn SQL3Step( statement ) == _SQLITEROW )resultsColumnData = fn CFDictionaryCreateMutable( _kCFAllocatorDefault, 0, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )rowCount++ 'increment rowCountfor curColumn = 0 to fn SQL3DataCount( statement ) - 1'get the SQLite column typecolumnType = fn SQL3ColumnType( statement, curColumn )columnName = fn SQL3ColumnName( statement, curColumn )if rowCount = 1fn CFDictionaryAddValue( resultsMetadata, columnName, @( columnType ))end if' fn NSLog( @"%@ type is: %ld", columnName, columnType )select case columnTypecase _SQLITEINTEGER' fn NSLog( @"%@ = %ld", columnName, fn SQL3ColumnInt( statement, curColumn ))fn CFDictionaryAddValue( resultsColumnData, columnName, @(fn SQL3ColumnInt( statement, curColumn )))case _SQLITEFLOAT' fn NSLog( @"%@ = %g", columnName, fn SQL3ColumnDouble( statement, curColumn ))fn CFDictionaryAddValue( resultsColumnData, columnName, @(fn SQL3ColumnDouble( statement, curColumn )))case _SQLITE3TEXT' fn NSLog( @"%@ = %@", columnName , fn SQL3ColumnText( statement, curColumn ))fn CFDictionaryAddValue( resultsColumnData, columnName, fn SQL3ColumnText( statement, curColumn ))case _SQLITEBLOB' fn NSLog( @"%@ = %@", columnName , @"is a BLOB" )case _SQLITENULL' fn NSLog( @"%@ = %@", columnName , @"is NULL" )fn CFDictionaryAddValue( resultsColumnData, columnName, NULL )case elsefn NSLog( @"column type not handled" )end selectnext curColumnfn CFArrayAppendValue( resultsDataArrayRef, resultsColumnData )wendfn CFDictionaryAddValue( queryResults, @"metadata", resultsMetadata )fn CFDictionaryAddValue( queryResults, @"data", resultsDataArrayRef )fn SQL3Finalize( statement )end fn = queryResultslocal modeCFMutableDictionaryRef    filterDictionaryRefCFStringRef               columnValueStrRefNSUInteger                sqlFilterCount, iSInt32                    aIntValuedouble                    aDoubleValuesqlite3_stmtPtr           statementCFNumberRef               myOperator, columnTypeNumRef, columnValueReflong                      rc, aType/* Initialize the Query Dictionary and the structures inside  * that generated a query  * in this case   *  * relationships: associations  *        tables: selecttables  *       columns: selectcols  *  associations: filter  *        filter: filter  *        filter: filter  *       results: results  *  *  *  SQLite bind  *  *  int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));  *  int sqlite3_bind_double(sqlite3_stmt*, int, double);  *  int sqlite3_bind_int(sqlite3_stmt*, int, int);  *  int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);  *  int sqlite3_bind_null(sqlite3_stmt*, int);  *  int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));  *  int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));  *  int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);  *  int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);  *  *  */local fn BuildPreparedStatement_Select( myDbHandle as sqlite3Ptr, mySQLString as CFStringRef, selectfilterArrayRef as CFMutableArrayRef ) as sqlite3_stmtPtr'fn CFStringGetCString( mySQLString, @sql, fn CFStringGetLength( mySQLString ) + 1, _kCFStringEncodingUTF8 )if ( fn SQL3PrepareV2( myDbHandle, mySQLString, @statement ) == _SQLITEOK )sqlFilterCount = fn ArrayCount( selectfilterArrayRef )fn NSLog( @"SQL Filter Count = %ld", sqlFilterCount )fn NSLog( @"SQL Filter = %@", selectfilterArrayRef )for i = 1 to sqlFilterCountfilterDictionaryRef = (CFMutableDictionaryRef) fn CFArrayGetValueAtIndex( selectfilterArrayRef, i -1 )columnTypeNumRef = fn CFDictionaryGetValue( filterDictionaryRef, @"type" )'fn NSLog( @"Bind Type = %@", columnTypeStrRef )if ( fn CFNumberGetValue( columnTypeNumRef, fn CFNumberGetType( columnTypeNumRef ), @aType ))fn NSLog( @"Bind Type = %U", aType )elsefn NSLog( @"Error getting Type" )end ifmyOperator = fn CFDictionaryGetValue( filterDictionaryRef, @"operator" )select case aTypecase _integerTypecolumnValueRef = fn CFDictionaryGetValue( filterDictionaryRef, @"value" )fn CFNumberGetValue( columnValueRef, fn CFNumberGetType( columnValueRef ), @aIntValue )rc = fn SQL3BindInt( statement, i, aIntValue )'fn NSLog( @"exec5 = %ld", rc )'Should be zerofn NSLog( @"Bind Value = %U", aIntValue )case _realTypeaDoubleValue = fn CFStringGetIntValue( fn CFDictionaryGetValue( filterDictionaryRef, @"value" ))rc = fn SQL3BindDouble( statement, i, aDoubleValue )case _textTypecolumnValueStrRef = fn CFDictionaryGetValue( filterDictionaryRef, @"value" )if columnValueStrRef != NULL'fn NSLog( @"Filter Value: '%@'", columnValueStrRef )rc = fn SQL3BindText( statement, i, columnValueStrRef, fn CFStringGetLength( columnValueStrRef ), _TRANSIENT )end ifcase _blobType: // fn CFStringAppend(mySQLString, fn CFDictionaryGetValue(filterDictionaryRef, @"value"))end selectnext iend if' how many statement params'fn NSLog( @"Statement Param count = %ld", fn sqlite3_bind_parameter_count( statement ))'for i = 1 to fn sqlite3_bind_parameter_count( statement )'	fn NSLog( @"Bind column: %@ Index: %ld", fn sqlite3_bind_parameter_name( statement, i ), i )'next i'fn NSLog( @"SQL = %@", mySQLString )end fn = statement