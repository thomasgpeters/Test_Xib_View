// Returns number of recordslocal fn GetSQLRecordCount( tableName as CFStringRef ) as NSInteger'~'1NSInteger        dbRecords = -1sqlite3_stmtPtr  statement = NULLCFStringRef      queryif ( fn SQL3Open( fn URLPath( gDatabaseURL ), @gDatabasePtr ) == _SQLITEOK )query = fn StringWithFormat( @"SELECT COUNT(*) FROM %@", tableName )fn SQL3PrepareV2( gDatabasePtr, query, @statement )while ( fn SQL3Step( statement ) == _SQLITEROW )dbRecords = fn SQL3ColumnInt( statement, 0 )wendend iffn SQL3Close( gDatabasePtr )end fn = dbRecords// Loads SQLite3 into an array for populating FB fieldslocal fn BuildDataForGUI as CFArrayRef'~'1sqlite3_stmtPtr    statementNSInteger          i, countCFStringRef        name, surname, address, city, state, zip, phoneCFArrayRef         tempArrCFMutableArrayRef  mutArr = NULLCFArrayRef         resultArr = NULLmutArr = fn MutableArrayWithCapacity( 0 )if ( fn SQL3Open( fn URLPath( gDatabaseURL ), @gDatabasePtr ) == _SQLITEOK )if ( fn SQL3PrepareV2( gDatabasePtr, @"SELECT name, surname, address, city, state, zip, phone FROM contacts", @statement ) == _SQLITEOK )i = 1count = 0while ( fn SQL3Step( statement ) == _SQLITEROW )name    = fn SQL3ColumnText( statement, _firstCol   )surname = fn SQL3ColumnText( statement, _secondCol  )address = fn SQL3ColumnText( statement, _thirdCol   )city    = fn SQL3ColumnText( statement, _fourthCol  )state   = fn SQL3ColumnText( statement, _fifthCol   )zip     = fn SQL3ColumnText( statement, _sixthCol   )phone   = fn SQL3ColumnText( statement, _seventhCol )//~NSLog( @"Record #%ld:\n%@ %@\n%@\n%@, %@ %@\n%@\n", i, name, surname, address, city, state, zip, phone )tempArr = @[name, surname, address, city, state, zip, phone]MutableArrayAddObject( mutArr, tempArr )i++count++wendfn SQL3Finalize( statement )elseControlSetStringValue( _status1Label, @"Query failed." )end iffn SQL3Close( gDatabasePtr )elseControlSetStringValue( _status1Label, @"Couldn't open database." )end ifresultArr = fn ArrayWithArray( mutArr )end fn = resultArrlocal fn ResetCounters'~'1NSInteger totalRecordstotalRecords = fn GetSQLRecordCount( @"contacts" )ControlSetStringValue( _status2Label, fn StringWithFormat( @"There are %d records in the SQL database.", totalRecords ))StepperSetMaxValue( _stepper, totalRecords )end fn// This will also delete any identical duplicate recordslocal fn DeleteRecord'~'1CFStringRef      aString, deleteSQLsqlite3_stmtPtr  statementif ( fn FileManagerFileExistsAtURL( gDatabaseURL ) == _false )ControlSetStringValue( _status1Label, @"Database missing. Relaunch app to create new database." )exit fnelseif ( fn SQL3Open( fn URLPath( gDatabaseURL ), @gDatabasePtr ) == _SQLITEOK )aString = fn ControlStringValue( _firstNameField )deleteSQL = fn StringWithFormat( @"DELETE FROM contacts WHERE name='%@'", aString	 )if ( fn SQL3PrepareV2( gDatabasePtr, deleteSQL, @statement ) == _SQLITEOK )if ( _SQLITEDONE != fn SQL3Step( statement ) )ControlSetStringValue( _status1Label, @"Error while deleting." )elseControlSetStringValue( _firstNameField, @"" )ControlSetStringValue( _surnameField,   @"" )ControlSetStringValue( _addressField,   @"" )ControlSetStringValue( _cityField,      @"" )ControlSetStringValue( _stateField,     @"" )ControlSetStringValue( _zipField,       @"" )ControlSetStringValue( _phoneField,     @"" )ControlSetStringValue( _status1Label, @"Record deleted." )end ifend iffn SQL3Finalize( statement )fn SQL3Close( gDatabasePtr )fn ResetCountersend ifend ifend fn// Shows all SQLite3 records in NSLoglocal fn ShowAllRecords'~'1sqlite3_stmtPtr  statementNSInteger        i, anID, personIDCFStringRef      type, contactif ( fn SQL3Open( fn URLPath( gDatabaseURL ), @gDatabasePtr ) == _SQLITEOK )if ( fn SQL3PrepareV2( gDatabasePtr, @"SELECT id, personID, type, contact FROM contact", @statement ) == _SQLITEOK )//~NSLogCleari = 1while ( fn SQL3Step( statement ) == _SQLITEROW )anID     = fn SQL3ColumnInt( statement,  _firstCol  )personID = fn SQL3ColumnInt( statement,  _secondCol )type     = fn SQL3ColumnText( statement, _thirdCol  )contact  = fn SQL3ColumnText( statement, _fourthCol )//~NSLog( @"Type :%@ Contact :%@", type, contact )i++wendfn SQL3Finalize( statement )elseControlSetStringValue( _status1Label, @"Query failed." )end iffn SQL3Close( gDatabasePtr )elseControlSetStringValue( _status1Label, @"Couldn't open database." )end ifend fn// Wanring before deleting all datavoid local fn DataDeleteAlert'~'1alert -_dataDeleteAlert, NSAlertStyleCritical, @"WARNING: This will remove all data from your SQLite database, but it does not delete the empty contacts.db file on your Desktop.", @"Be sure you really want to delete your data.", @"Delete All Data;Cancel"AlertButtonSetKeyEquivalent( _dataDeleteAlert, 1, @"\e" )alert _dataDeleteAlertend fnlocal fn PopulateFieldsWithData'~'1CFArrayRef mutArr, fldArrmutArr = fn BuildDataForGUIfldArr = fn ArrayObjectAtIndex( mutArr, 0 )' fn InsertArrayDataIntoFields( fldArr )end fnvoid local fn CreateTableData'~'1CFMutableArrayRef        arrayCFMutableDictionaryRef   dictCFIndex                  row, colCFStringRef              identifier, stringarray = fn TableViewData(1)for row = 0 to 100dict = fn MutableDictionaryWithCapacity(0)for col = 0 to 4identifier = fn StringWithFormat( @"Col%ld", col )string = fn StringWithFormat( @"Cell %ld,%ld", row, col )MutableDictionarySetObjectForKey( dict, string, identifier )next colMutableArrayAddObject( array, dict )next rowTableViewReloadData( 1 )end fnlocal modedim as CFMutableDictionaryRef   queryDictionaryRef/* * this returns a dictionary * that generated a query * in this case creates a query * * table:  memos * column: task * column: priority  */local fn SelectMemosQuery as CFMutableDictionaryRef'~'1queryDictionaryRef = fn InitQueryDictionaryfn AddTableToQuery( queryDictionaryRef, @"memos", @"a" )fn AddColumnToQuery( queryDictionaryRef, @"task", @"Task" )fn AddColumnToQuery( queryDictionaryRef, @"priority", @"Priority" )fn AddFilterToQuery( queryDictionaryRef, @"a", @"priority", @"100", _integerType, _kCFNumberLongType, _isEqual, NULL )// Here are some other filter examples// fn AddFilterToQuery( queryDictionaryRef, @"a", @"task", @"drink%%", _textType, NULL, _isLike, NULL )// fn AddFilterToQuery( queryDictionaryRef, @"a", @"task", @"drink beer", _textType, NULL, _isEqual, NULL )// fn AddFilterToQuery( queryDictionaryRef, @"a", @"priority", @"10", _integerType, _kCFNumberLongType, _isEqual, _or )end fn = queryDictionaryReflocal modedim as CFMutableDictionaryRef   queryDictionaryReflocal fn SelectDirectionsQuery as CFMutableDictionaryRef'~'1queryDictionaryRef = fn InitQueryDictionaryfn AddTableToQuery( queryDictionaryRef, @"directions", @"a" )fn AddColumnToQuery( queryDictionaryRef, @"direction", @"Direction" )fn AddColumnToQuery( queryDictionaryRef, @"synonym", @"Synonym" )end fn = queryDictionaryReflocal modedim as CFMutableDictionaryRef   insertIntoDictionaryRef/* * Storage Class & Description * 1 NULL    The value is a NULL value. * 2 INTEGER The value is a signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes depending on the magnitude of the value. * 3 REAL    The value is a floating point value, stored as an 8-byte IEEE floating point number. * 4 TEXT    The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE) * 5 BLOB    The value is a blob of data, stored exactly as it was input. * * _nullType * _integerType * _realType * _textType * _blobType * */local fn InsertIntoMemos as CFMutableDictionaryRef'~'1insertIntoDictionaryRef = fn InitInsertIntoDictionaryfn AddTableToInsert( insertIntoDictionaryRef, @"memos" )fn AddColumnToInsert( insertIntoDictionaryRef, @"task", @"Finish Insert Logic for SQL String", @"TEXT" )fn AddColumnToInsert( insertIntoDictionaryRef, @"priority", @"100", @"INTEGER" )end fn = insertIntoDictionaryReflocal fn ContactListDataDict( anID as NSInteger, item as CFStringRef ) as CFMutableDictionaryRef'~'1CFMutableDictionaryRef   dictdict = fn MutableDictionaryWithCapacity(0)fn MutableDictionarySetObjectForKey( dict, item, anID )end fn = dictvoid local fn ContactListAddRow( array as CFMutableArrayRef, anID as NSInteger, item as CFStringRef )'~'1fn MutableArrayAddObject( array, fn ContactListDataDict( anID,  item ))end fn// this is my SQL test applocal fn TestSQLiteInsert'~'1dim as CFMutableDictionaryRef   insertDictionaryRefdim as CFMutableStringRef       mySQLStringif ( gDBIsConnected )insertDictionaryRef = fn InsertIntoMemosmySQLString = fn GenerateInsertIntoSQL( insertDictionaryRef )'resultsDictionaryRef = fn ExecutePreparedStatement( fn BuildPreparedStatement_Select( gDbHandle, mySQLString, fn GetSelectFilterArray( queryDictionaryRef )))fn NSLog( @"SQLite Insert: %@", mySQLString )elsefn NSLog( @"Could not reopen the DB" )end ifend fnvoid local fn TableDataAddRow( array as CFMutableArrayRef, item as CFStringRef )'~'1MutableArrayAddObject( array, item )end fn